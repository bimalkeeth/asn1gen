package org.asn1gen.gen.scala

import java.io.PrintWriter
import org.asn1gen.gen.AsnCodeGenerationException
import org.asn1gen.extra.Extras._
import org.asn1gen.io._
import org.asn1gen.parsing.asn1.{ast => ast}
import scala.collection.immutable.Set

class GenScala(packageName: String, out: IndentWriter) {
  val keywords = Set("yield", "type", "null", "final")
  
  def safeId(id: String): String = {
    if (keywords contains id) {
      return "`" + id + "`"
    } else {
      return id.replaceAll("-", "_")
    }
  }
  
  def generate(module: Module): Unit = {
    ( out
      << "/* This file was generated by asn1gen */" << EndLn
      << EndLn
      << "package " << packageName << EndLn
      << EndLn
      << "import org.asn1gen.{runtime => _rt_}" << EndLn
      << "import " << packageName << ".{meta => _meta_}" << EndLn
      << EndLn
      << "object " << safeId(module.name) << " {" << EndLn
    )
    out.indent(2) {
      out << "import " << packageName << ".meta.{" << safeId(module.name) << " => _meta_}" << EndLn
      module.imports foreach { symbolsFromModule =>
        out << "import " << symbolsFromModule.module << "._" << EndLn
      }
      out << EndLn
      module.types.foreach { case (_, namedType: NamedType) =>
        generate(namedType)
      }
      module.values foreach { case (name, namedValue) =>
        generate(namedValue)
      }
    }
    out << "}" << EndLn
  }
  
  def generate(namedValue: NamedValue): Unit = {
    namedValue match {
      case NamedValue(name, ast.Type(ast.INTEGER(None), _), ast.SignedNumber(negative, ast.Number(magnitude))) => {
        out << "lazy val " << name << " = "
        if (negative) {
          out << "-"
        }
        out << magnitude << EndLn
      }
      case NamedValue(name, ast.Type(ast.BOOLEAN, _), ast.BooleanValue(booleanValue)) => {
        out << "lazy val " << name << " = " << booleanValue << EndLn
      }
      case NamedValue(name, ast.Type(ast.OctetStringType, _), ast.CString(stringValue)) => {
        out << "lazy val " << name << " = " << stringValue.inspect << EndLn
      }
      case NamedValue(name, typePart, valuePart) => {
        typePart match {
          case ast.Type(ast.TypeReference(typeName), _) => {
            out << "lazy val " << name << " = " << typeName << EndLn
          }
        }
        out.indent(2) {
          valuePart match {
            case ast.SequenceValue(memberValues) => {
              memberValues.foreach { memberValue =>
                memberValue match {
                  case ast.NamedValue(ast.Identifier(id), value) => {
                    out << "." << safeId(id) << " { " << "_ => "
                    value match {
                      case ast.CString(stringValue) => {
                        out << "_rt_.AsnOctetString(" << stringValue.inspect << ")"
                      }
                      case ast.ValueReference(valueReferenceName) => {
                        out << safeId(valueReferenceName)
                      }
                      case ast.BooleanValue(booleanValue) => {
                        out << booleanValue
                      }
                      
                    }
                    out << " }" << EndLn
                  }
                }
              }
            }
          }
        }
      }
      case x => {
        out << "/* unknown value " << x << " */" << EndLn
      }
    }
  }
  
  def generate(namedType: NamedType): Unit = {
    namedType._type match {
      case ast.Type(builtinType: ast.BuiltinType, _) => {
        generate(builtinType, namedType.name)
      }
      case t@ast.Type(referencedType: ast.ReferencedType, _) => {
        referencedType match {
          case ast.TypeReference(name) => {
            out.ensureEmptyLines(1)
            out << "type " << safeId(namedType.name) << " = " << safeId(name) << EndLn
            out << "lazy val " << safeId(namedType.name) << " = " + safeId(name) << EndLn
          }
          case _ => {
            out << "/* referencedType" << EndLn
            out << referencedType << EndLn
            out << "*/" << EndLn
          }
        }
      }
      case t@ast.Type(_, _) => {
        out << "/* unknown: " << namedType.name << EndLn
        out << t << EndLn
        out << "*/" << EndLn
      }
    }
  }
  
  def generate(builtinType: ast.BuiltinType, assignmentName: String): Unit = {
    val safeAssignmentName = safeId(assignmentName)
    builtinType match {
      case ast.ChoiceType(
        ast.AlternativeTypeLists(rootAlternativeTypeList, _, _, _))
      => {
        ( out
          << "abstract class " << safeAssignmentName
          << "(_element: Any) extends _rt_.AsnChoice {" << EndLn
        )
        out.indent(2) {
          out << "def _choice: Int" << EndLn
          generateSimpleGetters(rootAlternativeTypeList)
          generateChoiceFieldTransformers(assignmentName, rootAlternativeTypeList)
        }
        out << "}" << EndLn
        generateChoices(assignmentName, rootAlternativeTypeList)
        val firstNamedType =
          rootAlternativeTypeList.alternativeTypeList.namedTypes(0)
        ( out
          << EndLn
          << "object " << safeAssignmentName << " extends "
          << safeId(assignmentName + "_" + firstNamedType.name)
          << "(" << defaultNameOf(firstNamedType._type) << ") {" << EndLn
        )
        out.indent(2) {
          generateChoiceValAliases(assignmentName, rootAlternativeTypeList)
          generateChoiceTypeAliases(assignmentName, rootAlternativeTypeList)
        }
        out << "}" << EndLn
      }
      case ast.SequenceType(ast.Empty) => {
        out.ensureEmptyLines(1)
        out << "class " << safeAssignmentName << " extends _rt_.AsnSequence {" << EndLn
        out.indent(2) {
          ( out
            << "override def _desc: _meta_." << safeAssignmentName
            << " = _meta_." << safeAssignmentName << EndLn << EndLn
          )
        }
        ( out
          << "}" << EndLn
          << EndLn
          << "object " << safeAssignmentName << " extends " << safeAssignmentName << " {" << EndLn
          << "}" << EndLn
        )
      }
      case ast.SequenceType(ast.ComponentTypeLists(list1, extension, list2)) => {
        val list = (list1.toList:::list2.toList).map { componentTypeList =>
          componentTypeList.componentTypes
        }.flatten
        out.ensureEmptyLines(1)
        out << "class " << safeAssignmentName << "(" << EndLn
        out.indent(2) {
          generateSequenceFieldDefines(assignmentName, list)
          out << EndLn
        }
        out << ") extends _rt_.AsnSequence {" << EndLn
        out.indent(2) {
          ( out
            << "override def _desc: _meta_." << safeAssignmentName
            << " = _meta_." << safeAssignmentName << EndLn
            << EndLn
            << "def copy(" << EndLn
          )
          out.indent(2) {
            out.indent(2) {
              generateSequenceCopyParameters(list)
              out << ") = {" << EndLn
            }
            out << safeAssignmentName << "(" << EndLn
            out.indent(2) {
              list1 match {
                case Some(ast.ComponentTypeList(list)) => {
                  generateSequenceFieldValues(assignmentName, list)
                }
                case None => ()
              }
              out << ")" << EndLn
            }
          }
          ( out
            << "}" << EndLn << EndLn
            << "override def equals(that: Any): Boolean = {" << EndLn
          )
          out.indent(2) {
            out << "val other = try {" << EndLn
            out.indent(2) {
              out << "that.asInstanceOf[" << safeAssignmentName << "]" << EndLn
            }
            out << "} catch {" << EndLn
            out.indent(2) {
              out << "case e: ClassCastException => return false" << EndLn
            }
            out << "}" << EndLn
            out << "this.equals(other: " << safeAssignmentName + ")" << EndLn
          }
          out << "}" << EndLn << EndLn
          out << "def equals(that: " << safeAssignmentName << "): Boolean = {" << EndLn
          out.indent(2) {
            list foreach {
              case ast.NamedComponentType(ast.NamedType(ast.Identifier(identifier), _), value) => {
                out << "if (this." << safeId(identifier) << " != that." << safeId(identifier) << ")"
                out.indent(2) {
                  out << "return false" << EndLn
                }
              }
            }
            out << "return true" << EndLn
          }
          out << "}" << EndLn
          out << EndLn
          out << "override def hashCode(): Int = return (" << EndLn
          out.indent(2) {
            out << "0" << EndLn
            list foreach {
              case ast.NamedComponentType(ast.NamedType(ast.Identifier(identifier), _), value) => {
                out << "^ this." << safeId(identifier) << ".hashCode" << EndLn
              }
            }
          }
          out << ")" << EndLn << EndLn
          generateSequenceImmutableSetters(assignmentName, list)
          out << EndLn << EndLn << "override def _child(name: String): Any = name match {"
          out.indent(2) {
            list foreach {
              case ast.NamedComponentType(ast.NamedType(ast.Identifier(identifier), _), value) => {
                out << "case \"" << safeId(identifier) << "\" => " << safeId(identifier) << EndLn
              }
            }
            out << "case _ => throw new Exception("
            out << "\"Member '\" + name + \"' does not exist.\")" << EndLn
          }
          out << "}" << EndLn
        }
        out << "}" << EndLn
        out << EndLn
        out << "object " << safeAssignmentName << " extends " << safeAssignmentName << "("
        out.indent(2) {
          out << EndLn
          var firstItem = true
          list.map {
            case ast.NamedComponentType(
              ast.NamedType(_, _type),
              optionalDefault)
            => {
              if (!firstItem) {
                out << "," << EndLn
              }
              optionalDefault match {
                case ast.Empty => {
                  out << safeId(defaultNameOf(_type))
                }
                case ast.Optional => {
                  out << "None"
                }
                case ast.Default(ast.ValueReference(valueName)) => {
                  out << "/* default */ " << valueName
                }
              }
              firstItem = false
            }
          }
          out << EndLn
        }
        out << ") {" << EndLn
        out.indent(2) {
          out << "def apply(" << EndLn
          out.indent(2) {
            out.indent(2) {
              generateSequenceFieldParameters(assignmentName, list)
              out << "): " << safeAssignmentName << " = {" << EndLn
            }
            out << "new " << safeAssignmentName << "("
            out.indent(2) {
              generateSequenceFieldValues(assignmentName, list)
              out << ")" << EndLn
            }
          }
          out << "}" << EndLn
        }
        out << "}" << EndLn << EndLn
      }
      case ast.EnumeratedType(enumerations)
      => {
        var firstIndex: Option[Long] = None
        out.ensureEmptyLines(1)
        out << "case class " << safeAssignmentName
        out << "(_value: Long) extends _rt_.AsnEnumeration {" << EndLn
        out.indent(2) {
          out << "override def _desc: _meta_." << safeAssignmentName
          out << " = _meta_." << safeAssignmentName << EndLn
          out << EndLn
          out << "override def _shortName: Option[String] = {" << EndLn
          out.indent(2) {
            out << "_value match {" << EndLn
            out.indent(2) {
              enumerations match {
                case ast.Enumerations(ast.RootEnumeration(ast.Enumeration(items)), extension)
                => {
                  var index: Long = 0
                  items foreach {
                    case ast.Identifier(item) => {
                      out << "case " << index << " => Some(" << safeId(item).inspect() << ")" << EndLn
                      if (firstIndex == None) {
                        firstIndex = Some(index)
                      }
                      index = index + 1
                    }
                    case ast.NamedNumber(ast.Identifier(item), ast.SignedNumber(sign, ast.Number(n))) => {
                      val number = java.lang.Long.parseLong(n)
                      val value = if (sign) number * -1 else number
                      out << "case " << value << " => Some(" << safeId(item).inspect() << ")" << EndLn
                      if (firstIndex == None) {
                        firstIndex = Some(value)
                      }
                      index = index + 1
                    }
                  }
                }
              }
              out << "case _ => None" << EndLn
            }
            out << "}" << EndLn
          }
          out << "}" << EndLn
        }
        out << "}" << EndLn
        out << EndLn
        out << "object " << safeAssignmentName << " extends "
        out << safeAssignmentName << "(" << firstIndex.getOrElse(0L) << ") {" << EndLn
        out.indent(2) {
          generateEnumeratedValues(enumerations, assignmentName)
          out << EndLn
          out << "def of(name: String): " << safeId(assignmentName) << " = {" << EndLn
          out.indent(2) {
            out << "name match {" << EndLn
            out.indent(2) {
              enumerations match {
                case ast.Enumerations(ast.RootEnumeration(ast.Enumeration(items)), extension)
                => {
                  var index = 0
                  items foreach {
                    case ast.Identifier(item) => {
                      out << "case " << safeId(item).inspect << " => " << safeId(item) << EndLn
                      index = index + 1
                    }
                    case ast.NamedNumber(ast.Identifier(item), ast.SignedNumber(sign, ast.Number(n))) => {
                      out << "case " << safeId(item).inspect << " => " + safeId(item) << EndLn
                      index = index + 1
                    }
                  }
                  extension match {
                    case None => {}
                    case _ => out << extension << EndLn
                  }
                }
              }
              out << "case _ => throw _rt_.BadEnumerationException(" << EndLn
              out.indent(2) {
                out << "\"Unrecogonised enumeration value + '\" + name + \"'\")" << EndLn
              }
            }
            out << "}" << EndLn
          }
          out << "}" << EndLn << EndLn
          out << "def of(value: Int): " << safeId(assignmentName) << " = {" << EndLn
          out.indent(2) {
            out << "value match {" << EndLn
            out.indent(2) {
              enumerations match {
                case ast.Enumerations(ast.RootEnumeration(ast.Enumeration(items)), extension)
                => {
                  var index = 0
                  items foreach {
                    case ast.Identifier(item) => {
                      out << "case " << index << " => " << safeId(item) << EndLn
                      index = index + 1
                    }
                    case ast.NamedNumber(ast.Identifier(item), ast.SignedNumber(sign, ast.Number(n))) => {
                      val value = if (sign) n * -1 else n
                      out << "case " << value << " => " + safeId(item) << EndLn
                      index = index + 1
                    }
                  }
                  extension match {
                    case None => {}
                    case _ => out << extension << EndLn
                  }
                }
              }
              out << "case _ => " << safeId(assignmentName) << "(value)" << EndLn
            }
            out << "}" << EndLn
          }
          out << "}" << EndLn
        }
        out << "}" << EndLn
        out << EndLn
        generateEnumeratedValues(enumerations, assignmentName)
      }
      case setOfType: ast.SetOfType => {
        generate(assignmentName, setOfType)
      }
      case bitStringType: ast.BitStringType => {
        out.ensureEmptyLines(1)
        ( out
          << "type " << safeAssignmentName << " = _rt_.AsnBitString" << EndLn
          << EndLn
          << EndLn
          << "lazy val " << safeAssignmentName << " = _rt_.AsnBitString" << EndLn
        )
      }
      case ast.INTEGER(None) => {
        out.ensureEmptyLines(1)
        ( out
          << "type " << safeAssignmentName << " = Long" << EndLn
          << EndLn
          << "lazy val " << safeAssignmentName << " = 0L" << EndLn
        )
      }
      case ast.BOOLEAN => {
        out.ensureEmptyLines(1)
        ( out
          << "type " << safeAssignmentName << " = Boolean" << EndLn
          << EndLn
          << "lazy val " << safeAssignmentName << " = false" << EndLn
        )
      }
      case ast.OctetStringType => {
        out.ensureEmptyLines(1)
        ( out
          << "type " << safeAssignmentName << " = _rt_.AsnOctetString" << EndLn
          << EndLn
          << "lazy val " << safeAssignmentName << " = _rt_.AsnOctetString" << EndLn
        )
      }
      case ast.PrintableString => {
        out.ensureEmptyLines(1)
        ( out
          << "type " << safeAssignmentName << " = String" << EndLn
          << EndLn
          << "lazy val " << safeAssignmentName << " = \"\"" << EndLn
        )
      }
      case ast.REAL => {
        out.ensureEmptyLines(1)
        ( out
          << "type " << safeAssignmentName << " = Double" << EndLn
          << EndLn
          << "lazy val " << safeAssignmentName << " = 0.0" << EndLn
        )
      }
      case ast.UTF8String => {
        out.ensureEmptyLines(1)
        ( out
          << "type " << safeAssignmentName << " = String" << EndLn
          << EndLn
          << "lazy val " << safeAssignmentName << " = \"\"" << EndLn
        )
      }
      case unmatched => {
        out.ensureEmptyLines(1)
        out << "// Unmatched " << safeAssignmentName << ": " << unmatched << EndLn
      }
    }
  }
  
  def generateEnumeratedValues(
      enumerations: ast.Enumerations,
      assignmentName:String): Unit = {
    enumerations match {
      case ast.Enumerations(ast.RootEnumeration(ast.Enumeration(items)), extension)
      => {
        var index = 0
        items foreach {
          case ast.Identifier(item) => {
            out << "val " << safeId(item) << " = " << safeId(assignmentName) << "(" << index << ")" << EndLn
            index = index + 1
          }
          case ast.NamedNumber(ast.Identifier(item), ast.SignedNumber(sign, ast.Number(n))) => {
            val value = if (sign) n * -1 else n
            out << "val " << safeId(item) << " = " << safeId(assignmentName) << "(" << value << ")" << EndLn
            index = index + 1
          }
        }
        extension match {
          case None => {}
          case _ => out.println(extension)
        }
      }
    }
  }
  
  def generate(assignmentName: String, setOfType: ast.SetOfType): Unit = {
    val safeAssignmentName = safeId(assignmentName)
    setOfType match {
      case ast.SetOfType(ast.Type(elementType, _)) => {
        elementType match {
          case ast.TypeReference(referencedType) => {
            val safeReferenceType = safeId(referencedType)
            out.ensureEmptyLines(1)
            ( out
              << "case class " << safeAssignmentName
              << "(items: List[" << safeReferenceType << "]) "
              << "extends _rt_.AsnList {" << EndLn
            )
            out.indent(2) {
              ( out
                << "override def _desc: _meta_." << safeAssignmentName
                << " = _meta_." << safeAssignmentName << EndLn
                << EndLn
                << "def items(f: (List[" << safeReferenceType << ("] => List[")
                << safeReferenceType << "])): " << safeAssignmentName
                << " =" << EndLn
              )
              out.indent(2) {
                out << "this.copy(items = f(this.items))" << EndLn
              }
            }
            ( out
              << "}" << EndLn << EndLn
              << "object " << safeAssignmentName
              << " extends " <<  safeAssignmentName << "(Nil) {" << EndLn
            )
            out.indent(2) {
              ( out
                << "def apply(items: " << safeReferenceType
                << "*): " << safeAssignmentName << " = "
                << safeAssignmentName << "(items.toList)" << EndLn
              )
            }
            out << "}" << EndLn
          }
          case sequenceType: ast.SequenceType => {
            assert(false)
            val assignmentElementName = assignmentName + "_element"
            val safeAssignmentElementName = safeId(assignmentElementName)
            out.ensureEmptyLines(1)
            ( out
              << "type " << safeAssignmentName << " = List["
              << safeAssignmentElementName << "]" << EndLn
              << "lazy val " << safeAssignmentName << " = Nil: List["
              << safeAssignmentElementName << "]" << EndLn
            )
            generate(sequenceType, assignmentElementName)
          }
          case builtinType: ast.BuiltinType => {
            out.ensureEmptyLines(1)
            ( out
              << "type " << safeAssignmentName
              << " = List[" << typeNameOf(builtinType) << "]"
              << "lazy val " << safeAssignmentName
              << " = Nil: List[" << typeNameOf(builtinType) << "]"
            )
          }
        }
      }
    }
  }
  
  def typeNameOf(namedComponentType: ast.NamedComponentType): String = {
    namedComponentType match {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _type),
        value)
      => {
        typeNameOf(_type, value)
      }
    }
  }
  
  def typeNameOf(_type: ast.Type, value: ast.OptionalDefault[ast.Value]): String = {
    value match {
      case ast.Empty =>
        return typeNameOf(_type)
      case ast.Default(value) =>
        return typeNameOf(_type)
      case ast.Optional =>
        return "Option[" + typeNameOf(_type) + "]"
    }
  }
  
  def defaultNameOf(namedComponentType: ast.NamedComponentType): String = {
    namedComponentType match {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _type),
        value)
      => {
        defaultNameOf(_type, value)
      }
    }
  }
  
  def defaultNameOf(_type: ast.Type, value: ast.OptionalDefault[ast.Value]): String = {
    value match {
      case ast.Empty =>
        return typeNameOf(_type)
      case ast.Default(value) =>
        return defaultNameOf(_type)
      case ast.Optional =>
        return "None"
    }
  }
  
  def generateSequenceFieldDefines(
      sequenceName: String, list: List[ast.ComponentType]): Unit = {
    var firstTime = true
    list foreach {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _type),
        value)
      => {
        if (!firstTime) {
          out << "," << EndLn
        }
        out << "val " << safeId(identifier) << ": " << safeId(typeNameOf(_type, value))
        firstTime = false
      }
    }
  }
  
  def generateSequenceFieldParameters(
      sequenceName: String, list: List[ast.ComponentType]): Unit = {
    var firstTime = true
    list foreach {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _type),
        value)
      => {
        if (!firstTime) {
          out << "," << EndLn
        }
        out << safeId(identifier) << ": " << safeId(typeNameOf(_type, value))
        firstTime = false
      }
    }
  }
  
  def generateSequenceFieldValues(
      sequenceName: String, list: List[ast.ComponentType]): Unit = {
    var firstTime = true
    list foreach {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _type),
        value)
      => {
        if (!firstTime) {
          out << "," << EndLn
        }
        out << safeId(identifier)
        firstTime = false
      }
    }
  }
  
  def generateSequenceCopyParameters(
      list: List[ast.ComponentType]): Unit = {
    var firstTime = true
    list foreach {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _type),
        value)
      => {
        if (!firstTime) {
          out << "," << EndLn
        }
        out << safeId(identifier) << ": " << safeId(typeNameOf(_type, value)) << " = this." << safeId(identifier)
        firstTime = false
      }
    }
  }
  
  def defaultNameOf(_type: ast.Type): String = {
    _type match {
      case ast.Type(typeKind, _) => defaultNameOf(typeKind)
    }
  }
  
  def defaultNameOf(typeKind: ast.TypeKind): String = {
    typeKind match {
      case builtinType: ast.BuiltinType => defaultNameOf(builtinType)
      case usefulType: ast.UsefulType => defaultNameOf(usefulType)
      case ast.TypeReference(reference) => reference
      case unmatched => "UnmatchedDefaultName(" + unmatched + ")"
    }
  }
  
  def defaultNameOf(typeKind: ast.TypeKind, value: ast.OptionalDefault[ast.Value]): String = {
    value match {
      case ast.Empty =>
        return defaultNameOf(typeKind)
      case ast.Default(value) =>
        return defaultNameOf(typeKind)
      case ast.Optional =>
        return "None"
    }
  }
  
  def defaultNameOf(usefulType: ast.UsefulType): String = {
    usefulType match {
      case ast.GeneralizedTime => {
        return "_rt_.AsnGeneralizedTime"
      }
      case ast.ObjectDescriptor => {
        return "_rt_.AsnObjectDescriptor"
      }
      case ast.UTCTime => {
        return "_rt_.AsnUtcTime"
      }
      case unmatched => {
        return "UnknownUsefulType(" + unmatched + ")"
      }
    }
  }
  
  def defaultNameOf(builtinType: ast.BuiltinType): String = {
    builtinType match {
      case ast.BitStringType(_) => {
        return "_rt_.AsnBitString"
      }
      case ast.BOOLEAN => {
        return "false"
      }
      case characterString: ast.CharacterStringType => {
        defaultNameOf(characterString)
      }
      case _: ast.ChoiceType => {
        return "_rt_.AsnChoice"
      }
      case ast.EmbeddedPdvType => {
        return "_rt_.AsnEmbeddedPdv"
      }
      case ast.EnumeratedType(_) => {
        return "_rt_.AsnEnumeration"
      }
      case ast.EXTERNAL => {
        return "ExternalType"
      }
      case ast.InstanceOfType(_) => {
        return "InstanceOfType"
      }
      case ast.INTEGER(_) => {
        return "0L"
      }
      case ast.NULL => {
        return "_rt_.AsnNull"
      }
      case _: ast.ObjectClassFieldType => {
        return "_rt_.AsnObjectClassField"
      }
      case ast.ObjectIdentifierType => {
        return "_rt_.AsnObjectIdentifier"
      }
      case ast.OctetStringType => {
        return "_rt_.AsnOctetString"
      }
      case ast.REAL => {
        return "0.0"
      }
      case ast.RelativeOidType => {
        return "_rt_.AsnRelativeOidType"
      }
      case ast.SequenceOfType(_) => {
        return "_rt_.AsnSequenceOf"
      }
      case ast.SequenceType(_) => {
        return "_rt_.AsnSequence"
      }
      case ast.SetOfType(_) => {
        return "_rt_.AsnSetOf"
      }
      case ast.SetType(_) => {
        return "_rt_.AsnSet"
      }
      case ast.TaggedType(_, _, underlyingType) => {
        return defaultNameOf(underlyingType)
      }
      case unmatched => {
        return "UnknownBuiltinType(" + unmatched + ")"
      }
    }
  }
  
  def defaultNameOf(characterString: ast.CharacterStringType): String = {
    characterString match {
      case ast.BMPString => {
        return "_rt_.AsnBmpString"
      }
      case ast.GeneralString => {
        return "_rt_.AsnGeneralString"
      }
      case ast.GraphicString => {
        return "_rt_.AsnGraphicString"
      }
      case ast.IA5String => {
        return "_rt_.AsnIa5String"
      }
      case ast.ISO646String => {
        return "_rt_.AsnIso646String"
      }
      case ast.NumericString => {
        return "_rt_.AsnNumericString"
      }
      case ast.PrintableString => {
        return "\"\""
      }
      case ast.T61String => {
        return "_rt_.AsnT61String"
      }
      case ast.TeletexString => {
        return "_rt_.AsnTeletexString"
      }
      case ast.UniversalString => {
        return "_rt_.AsnUniversalString"
      }
      case ast.UTF8String => {
        return "\"\""
      }
      case ast.VideotexString => {
        return "_rt_.AsnVideotexString"
      }
      case ast.VisibleString => {
        return "_rt_.AsnVisibleString"
      }
      case unknown => {
        return "UnknownCharacterString(" + unknown + ")"
      }
    }
  }
  
  def typeNameOf(_type: ast.Type): String = {
    _type match {
      case ast.Type(typeKind, _) => typeNameOf(typeKind)
    }
  }
  
  def typeNameOf(typeKind: ast.TypeKind): String = {
    typeKind match {
      case builtinType: ast.BuiltinType => typeNameOf(builtinType)
      case usefulType: ast.UsefulType => typeNameOf(usefulType)
      case ast.TypeReference(reference) => reference
      case unmatched => "Unmatched(" + unmatched + ")"
    }
  }
  
  def typeNameOf(typeKind: ast.TypeKind, value: ast.OptionalDefault[ast.Value]): String = {
    value match {
      case ast.Empty =>
        return typeNameOf(typeKind)
      case ast.Default(value) =>
        return typeNameOf(typeKind)
      case ast.Optional =>
        return "Option[" + typeNameOf(typeKind) + "]"
    }
  }
  
  def typeNameOf(builtinType: ast.UsefulType): String = {
    builtinType match {
      case ast.GeneralizedTime => {
        return "_rt_.AsnGeneralizedTime"
      }
      case ast.ObjectDescriptor => {
        return "_rt_.AsnObjectDescriptor"
      }
      case ast.UTCTime => {
        return "_rt_.AsnUtcTime"
      }
      case unmatched => {
        return "UnknownUsefulType(" + unmatched + ")"
      }
    }
  }
  
  def typeNameOf(builtinType: ast.BuiltinType): String = {
    builtinType match {
      case ast.BitStringType(_) => {
        return "_rt_.AsnBitString"
      }
      case ast.BOOLEAN => {
        return "Boolean"
      }
      case characterString: ast.CharacterStringType => {
        typeNameOf(characterString)
      }
      case _: ast.ChoiceType => {
        return "_rt_.AsnChoice"
      }
      case ast.EmbeddedPdvType => {
        return "_rt_.AsnEmbeddedPdv"
      }
      case ast.EnumeratedType(_) => {
        return "_rt_.AsnEnumeration"
      }
      case ast.EXTERNAL => {
        return "ExternalType"
      }
      case ast.InstanceOfType(_) => {
        return "InstanceOfType"
      }
      case ast.INTEGER(_) => {
        return "Long"
      }
      case ast.NULL => {
        return "_rt_.AsnNull"
      }
      case _: ast.ObjectClassFieldType => {
        return "_rt_.AsnObjectClassField"
      }
      case ast.ObjectIdentifierType => {
        return "_rt_.AsnObjectIdentifier"
      }
      case ast.OctetStringType => {
        return "_rt_.AsnOctetString"
      }
      case ast.REAL => {
        return "Double"
      }
      case ast.RelativeOidType => {
        return "_rt_.AsnRelativeOidType"
      }
      case ast.SequenceOfType(_) => {
        return "_rt_.AsnSequenceOf"
      }
      case ast.SequenceType(_) => {
        return "_rt_.AsnSequence"
      }
      case ast.SetOfType(_) => {
        return "_rt_.AsnSetOf"
      }
      case ast.SetType(_) => {
        return "_rt_.AsnSet"
      }
      case ast.TaggedType(_, _, underlyingType) => {
        return typeNameOf(underlyingType)
      }
      case unmatched => {
        return "UnknownBuiltinType(" + unmatched + ")"
      }
    }
  }
  
  def typeNameOf(characterString: ast.CharacterStringType): String = {
    characterString match {
      case ast.BMPString => {
        return "_rt_.AsnBmpString"
      }
      case ast.GeneralString => {
        return "_rt_.AsnGeneralString"
      }
      case ast.GraphicString => {
        return "_rt_.AsnGraphicString"
      }
      case ast.IA5String => {
        return "_rt_.AsnIa5String"
      }
      case ast.ISO646String => {
        return "_rt_.AsnIso646String"
      }
      case ast.NumericString => {
        return "_rt_.AsnNumericString"
      }
      case ast.PrintableString => {
        return "String"
      }
      case ast.T61String => {
        return "_rt_.AsnT61String"
      }
      case ast.TeletexString => {
        return "_rt_.AsnTeletexString"
      }
      case ast.UniversalString => {
        return "_rt_.AsnUniversalString"
      }
      case ast.UTF8String => {
        return "String"
      }
      case ast.VideotexString => {
        return "_rt_.AsnVideotexString"
      }
      case ast.VisibleString => {
        return "_rt_.AsnVisibleString"
      }
      case unknown => {
        return "UnknownCharacterString(" + unknown + ")"
      }
    }
  }
  
  def generateSequenceImmutableSetters(sequenceName: String, list: List[ast.ComponentType]): Unit = {
    val fieldNames = list.map {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _),
        _)
      => identifier
    }
    list foreach {
      case ast.NamedComponentType(
        ast.NamedType(ast.Identifier(identifier), _type),
        value)
      => {
        generateSequenceImmutableSetter(
            sequenceName: String, identifier, _type, value, fieldNames)
      }
    }
  }
  
  def generateSequenceImmutableSetter(
      sequenceName: String,
      fieldName: String,
      _type: ast.Type,
      value: ast.OptionalDefault[ast.Value],
      fieldNames: List[String]): Unit = {
    _type match {
      case ast.Type(ast.TaggedType(_, _, fieldType), _) => {
        generateSequenceImmutableSetter(sequenceName, fieldName, fieldType, value, fieldNames)
        //out.println("// tag " + number)
      }
      case ast.Type(builtinType: ast.TypeKind, List()) => {
        val setterType = typeNameOf(builtinType, value)
        ( out
          << "def " << safeId(fieldName) << "(f: (" << setterType << " => "
          << setterType << ")): " << sequenceName << " =" << EndLn
        )
        out.indent(2) {
          out << "this.copy(" << safeId(fieldName) << " = f(this." << safeId(fieldName) << "))" << EndLn
        }
      }
      case unmatched => {
        out << "// Unmatched type: " << unmatched << EndLn
      }
    }
  }
  
  def generateChoices(
      assignmentName: String,
      rootAlternativeTypeList: ast.RootAlternativeTypeList): Unit = {
    rootAlternativeTypeList match {
      case ast.RootAlternativeTypeList(ast.AlternativeTypeList(namedTypes)) => {
        namedTypes foreach { namedType =>
          generateChoices(assignmentName, namedType)
        }
      }
    }
  }
  
  def generateChoices(
      assignmentName: String,
      namedType: ast.NamedType): Unit = {
    namedType match {
      case ast.NamedType(
        ast.Identifier(name),
        ast.Type(
          ast.TaggedType(
            ast.Tag(_, ast.Number(tagNumber)), _, _type),
          _))
      => {
        val safeName = safeId(name)
        val safeElementType = safeId(typeNameOf(_type))
        val safeChoiceType = safeId(assignmentName)
        val safeChoiceChoice = safeId(assignmentName + "_" + name)
        out.ensureEmptyLines(1)
        ( out
          << "case class " << safeChoiceChoice
          << "(_element: " << typeNameOf(_type) << ") extends "
          << safeId(assignmentName) << "(_element) {" << EndLn
        )
        out.indent(2) {
          ( out
            << "override def _desc: _meta_." << safeChoiceType
            << " = _meta_." << safeChoiceType
            << EndLn
            << "def _choice: Int = " + tagNumber
            << EndLn
            << EndLn
            << "override def "
            << safeName
            << ": Option[" << safeElementType << "] = Some(_element)"
            << EndLn
            << EndLn
            << "override def "
            << safeName
            << "(f: ("
            << safeElementType
            << " => "
            << safeElementType
            << ")): "
            << safeChoiceType
            << " = "
            << safeChoiceChoice
            << "(f(_element))"
            << EndLn
            << EndLn
            << "override def _choiceName: String = " << name.inspect
            << EndLn
          )
        }
        out << "}" << EndLn
      }
      case x => {
        throw new org.asn1gen.gen.AsnCodeGenerationException("CHOICE members need to be tagged: " + x)
      }
    }
  }

  def generateChoiceFieldTransformers(
      choiceTypeName: String,
      rootAlternativeTypeList: ast.RootAlternativeTypeList): Unit = {
    rootAlternativeTypeList match {
      case ast.RootAlternativeTypeList(ast.AlternativeTypeList(namedTypes)) => {
        namedTypes foreach { namedType =>
          generateChoiceFieldTransformer(choiceTypeName, namedType)
        }
      }
    }
  }
  
  def generateChoiceValAliases(
      choiceTypeName: String,
      rootAlternativeTypeList: ast.RootAlternativeTypeList): Unit = {
    rootAlternativeTypeList match {
      case ast.RootAlternativeTypeList(ast.AlternativeTypeList(namedTypes)) => {
        namedTypes foreach { namedType =>
          ( out
            << "val "
            << namedType.name.capitalise
            << " = "
            << choiceTypeName
            << "_"
            << namedType.name
            << EndLn
          )
        }
      }
    }
  }

  def generateChoiceTypeAliases(
      choiceTypeName: String,
      rootAlternativeTypeList: ast.RootAlternativeTypeList): Unit = {
    rootAlternativeTypeList match {
      case ast.RootAlternativeTypeList(ast.AlternativeTypeList(namedTypes)) => {
        namedTypes foreach { namedType =>
          ( out
            << "type "
            << namedType.name.capitalise
            << " = "
            << choiceTypeName << "_" << namedType.name
            << EndLn
          )
        }
      }
    }
  }

  def generateChoiceFieldTransformer(choiceTypeName: String, namedType: ast.NamedType): Unit = {
    namedType match {
      case ast.NamedType(
        ast.Identifier(name),
        _type)
      => {
        val safeElementName = safeId(name)
        val safeChoiceType = safeId(choiceTypeName)
        val safeChoiceChoice = safeId(choiceTypeName + "_" + name)
        val safeElementType = safeId(typeNameOf(_type))
        ( out
          << EndLn
          << "def "
          << safeElementName
          << "(f: ("
          << safeElementType
          << " => "
          << safeElementType
          << ")): "
          << safeChoiceType
          << " = this"
          << EndLn
          << EndLn
          << "def "
          << safeElementName
          << "(f: => "
          << safeElementType
          << "): "
          << safeChoiceType
          << " = "
          << safeChoiceChoice
          << "(f)"
          << EndLn
        )
      }
    }
  }

  def generateSimpleGetters(rootAlternativeTypeList: ast.RootAlternativeTypeList): Unit = {
    rootAlternativeTypeList match {
      case ast.RootAlternativeTypeList(ast.AlternativeTypeList(namedTypes)) => {
        namedTypes foreach { namedType =>
          generateSimpleGetters(namedType)
        }
      }
    }
  }
  
  def generateSimpleGetters(namedType: ast.NamedType): Unit = {
    namedType match {
      case ast.NamedType(
        ast.Identifier(name),
        _type)
      => {
    	val safeName = safeId(name)
    	val safeType = safeId(typeNameOf(_type))
        ( out
          << EndLn
          << "def "
          << safeName
          << ": Option[" << safeType << "] = None"
          << EndLn
        )
      }
    }
  }
}
