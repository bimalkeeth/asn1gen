package org.asn1gen.gen.scala

import java.io.PrintWriter
import org.asn1gen.extra.Extras._
import org.asn1gen.io._
import org.asn1gen.parsing.asn1.{ast => ast}
import scala.collection.immutable.Set

class GenScalaBerEncoder(packageName: String, out: IndentWriter) {
  val keywords = Set("yield", "type", "null", "final")
  
  def safeId(id: String): String = {
    if (keywords contains id) {
      return "`" + id + "`"
    } else {
      return id.replaceAll("-", "_")
    }
  }
  
  def generate(module: Module): Unit = {
    ( out
      << "/* This file was generated by asn1gen */" << EndLn
      << EndLn
      << "package " << packageName << ".codec.ber" << EndLn
      << EndLn
      << "import org.asn1gen.{runtime => _rt_}" << EndLn
      << "import org.asn1gen.{io => _io_}" << EndLn
      << "import moo.{ASNEXAMPLES => _m_}" << EndLn
      << EndLn
      << "trait " << safeId(module.name) << " extends _rt_.codec.BerEncoder {" << EndLn
      << EndLn
    )
    out.indent(2) {
      module.imports foreach { symbolsFromModule =>
        out << "import " << symbolsFromModule.module + "._" << EndLn
      }
      out << EndLn
      module.types.foreach { case (_, namedType: NamedType) =>
        generate(namedType)
      }
    }
    out << "}" << EndLn
  }
  
  def generate(namedType: NamedType): Unit = {
    namedType._type match {
      case ast.Type(builtinType: ast.BuiltinType, _) => {
        generate(builtinType, namedType.name)
      }
      case t@ast.Type(_, _) => {
        ( out
          << "/* unknown: " << namedType.name << EndLn
          << t << EndLn
          << "*/" << EndLn
        )
      }
    }
  }
  
  def generate(builtinType: ast.BuiltinType, assignmentName: String): Unit = {
    val safeAssignmentName = "_m_." + safeId(assignmentName)
    builtinType match {
      case ast.ChoiceType(
        ast.AlternativeTypeLists(rootAlternativeTypeList, _, _, _))
      => {
        out << "def encode(value: " << safeAssignmentName << "): _io_.ByteStreamer = _io_.ByteStreamer.nil" << EndLn
      }
      case ast.SequenceType(ast.Empty) => {
        out.ensureEmptyLines(1)
        out << "def encode(value: " << safeAssignmentName << "): _io_.ByteStreamer = _io_.ByteStreamer.nil" << EndLn
      }
      case ast.SequenceType(ast.ComponentTypeLists(list1, extension, list2)) => {
        val list = (list1.toList:::list2.toList).map { componentTypeList =>
          componentTypeList.componentTypes
        }.flatten
        out.ensureEmptyLines(1)
        out << "def encode(value: " << safeAssignmentName << "): _io_.ByteStreamer = _io_.ByteStreamer.nil" << EndLn
        out << EndLn
      }
      case ast.EnumeratedType(enumerations)
      => {
        var firstIndex: Option[Long] = None
        out.ensureEmptyLines(1)
        out << "def encode(value: " << safeAssignmentName << "): _io_.ByteStreamer = _io_.ByteStreamer.nil" << EndLn
        out << EndLn
      }
      case unmatched => {
        out.ensureEmptyLines(1)
        out << "// Unmatched " << safeAssignmentName << ": " << unmatched << EndLn
      }
    }
  }
}
